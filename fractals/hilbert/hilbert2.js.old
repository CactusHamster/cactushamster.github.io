class Hilbert {
	constructor (width, spac = 10, points = []) {
		this.width = width
		this.space = spac
		this.points = points
	}
	calc (x, y, lg, i1, i2) {
		if (lg === 1) {
			const px = (this.width - x) * this.space;
			const py = (this.width - y) * this.space;
			this.points.push([px, py]);
			return;
		}
		lg >>= 1;
		this.calc(x + i1 * lg, y + i1 * lg, lg, i1, 1 - i2);
		this.calc(x + i2 * lg, y + (1 - i2) * lg, lg, i1, i2);
		this.calc(x + (1 - i1) * lg, y + (1 - i1) * lg, lg, i1, i2);
		this.calc(x + (1 - i2) * lg, y + i2 * lg, lg, 1 - i1, i2);
		return this.points;
	}
}


function renderCalc (order, size) {
	order = Math.floor(order);
    const width = 2 ** order;
    const space = 10;
    const hil = new Hilbert(width, space, [])
    const points = hil.calc(0, 0, width, 0, 0, hil);
	return points;
 
};
const canvas = document.getElementsByTagName('canvas')[0]
const ctx = canvas.getContext('2d')
function render () {
	let s = 1000
	let p = renderCalc(6, s);
	canvas.width = s
	canvas.height = s
	ctx.fillStyle = '0xFFFFFF'
	for (let coordi in p) {
		if (coordi == 0) continue;
		let last = [p[coordi-1][0], p[coordi-1][1]]
		let dif = [(p[coordi][0] - last[0]), (p[coordi][1] - last[1])].map(a => a < 1 ? 1 : a)
		ctx.fillRect(...last, ...dif)
		//console.log(lastx, lasty, p[coordi][0] - lastx, p[coordi][1] - lasty)
	}
	return p;
}
render()