class Hilbert {
	constructor (width, spac = 10, points = []) {
		this.width = width
		this.space = spac
		this.points = points
	}
	calc (x, y, lg, i1, i2) {
		if (lg === 1) {
			const px = (this.width - x) * this.space;
			const py = (this.width - y) * this.space;
			this.points.push([px, py]);
			return;
		}
		lg >>= 1;
		this.calc(x + i1 * lg, y + i1 * lg, lg, i1, 1 - i2);
		this.calc(x + i2 * lg, y + (1 - i2) * lg, lg, i1, i2);
		this.calc(x + (1 - i1) * lg, y + (1 - i1) * lg, lg, i1, i2);
		this.calc(x + (1 - i2) * lg, y + i2 * lg, lg, 1 - i1, i2);
		return this.points;
	}
}


function renderCalc (order, size) {
	order = Math.floor(order);
    const width = 2 ** order;
    const space = 10;
    const hil = new Hilbert(width, space, [])
    const points = hil.calc(0, 0, width, 0, 0, hil);
	return points;
 
};
const canvas = document.getElementsByTagName('canvas')[0]
const ctx = canvas.getContext('2d')
async function render () {
	let s = 1000
	let p = renderCalc(6, s);
	canvas.width = s
	canvas.height = s
	ctx.fillStyle = '0xFFFFFF'
	for (let coordi in p) {
		if (coordi == 0) continue;
		let lastx = p[coordi-1][0]
		let lasty = p[coordi-1][1]
		let dif = [(p[coordi][0] - lastx), (p[coordi][1] - lasty)];
		dif = dif.map((a) => { if (a < 1) a++; return a; });
		ctx.fillRect(lastx, lasty, ...dif);
		//console.log(lastx, lasty, p[coordi][0] - lastx, p[coordi][1] - lasty)
		await (function () {
			return new Promise ((res, rej) => {
				setTimeout(res, 10)
			})
		})();
	}
	return p;
}